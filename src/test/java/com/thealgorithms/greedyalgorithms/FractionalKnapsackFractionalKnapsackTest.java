// ********RoostGPT********
/*
Test generated by RoostGPT for test Java-repo-test using AI Type Open AI and AI Model gpt-4
ROOST_METHOD_HASH=fractionalKnapsack_b327dd7d5e
ROOST_METHOD_SIG_HASH=fractionalKnapsack_1caf503527
Scenario 1: Test with a valid weight and value array with equal lengths
Details:
  TestName: testFractionalKnapsackWithValidArrays
  Description: This test is meant to check if the fractionalKnapsack function works as expected with valid weight and value arrays of equal lengths.
Execution:
  Arrange: Set up weight and value arrays of equal lengths with valid data.
  Act: Invoke the fractionalKnapsack function with the weight and value arrays and a valid capacity.
  Assert: Use JUnit assertions to compare the actual result against the expected outcome.
Validation:
  The assertion aims to verify that the function correctly calculates the maximum possible value that can be put in the knapsack. It is significant as it validates the core functionality of the function.
Scenario 2: Test with weight and value arrays of unequal lengths
Details:
  TestName: testFractionalKnapsackWithUnequalLengthArrays
  Description: This test is meant to check if the fractionalKnapsack function throws an appropriate exception when the weight and value arrays have different lengths.
Execution:
  Arrange: Set up weight and value arrays of different lengths.
  Act: Invoke the fractionalKnapsack function with the weight and value arrays and a valid capacity.
  Assert: Use JUnit assertions to expect an ArrayIndexOutOfBoundsException.
Validation:
  The assertion aims to verify that the function correctly handles the case where the weight and value arrays have different lengths by throwing an exception. This is crucial for error handling and avoiding unexpected behavior.
Scenario 3: Test with a zero capacity
Details:
  TestName: testFractionalKnapsackWithZeroCapacity
  Description: This test is meant to check if the fractionalKnapsack function returns zero when the capacity is zero.
Execution:
  Arrange: Set up valid weight and value arrays.
  Act: Invoke the fractionalKnapsack function with the weight and value arrays and a capacity of zero.
  Assert: Use JUnit assertions to expect a return value of zero.
Validation:
  The assertion aims to verify that the function correctly handles the case where the capacity is zero by returning zero. This is important for validating the function's correctness in edge cases.
Scenario 4: Test with negative weights or values
Details:
  TestName: testFractionalKnapsackWithNegativeWeightsOrValues
  Description: This test is meant to check if the fractionalKnapsack function throws an appropriate exception when the weight or value arrays contain negative numbers.
Execution:
  Arrange: Set up weight and value arrays containing negative numbers.
  Act: Invoke the fractionalKnapsack function with the weight and value arrays and a valid capacity.
  Assert: Use JUnit assertions to expect an IllegalArgumentException.
Validation:
  The assertion aims to verify that the function correctly handles the case where the weight or value arrays contain negative numbers by throwing an exception. This is crucial for error handling and avoiding unexpected behavior.
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.fractionalKnapsack")
public class FractionalKnapsackTest {

	@Test
	public void testFractionalKnapsackWithValidArrays() {
		int[] weight = new int[] { 10, 20, 30 };
		int[] value = new int[] { 60, 100, 120 };
		int capacity = 50;
		int expected = 240;
		assertEquals(expected, FractionalKnapsack.fractionalKnapsack(weight, value, capacity));
	}

	@Test
	public void testFractionalKnapsackWithUnequalLengthArrays() {
		int[] weight = new int[] { 10, 20, 30 };
		int[] value = new int[] { 60, 100 };
		int capacity = 50;
		assertThrows(ArrayIndexOutOfBoundsException.class,
				() -> FractionalKnapsack.fractionalKnapsack(weight, value, capacity));
	}

	@Test
	public void testFractionalKnapsackWithZeroCapacity() {
		int[] weight = new int[] { 10, 20, 30 };
		int[] value = new int[] { 60, 100, 120 };
		int capacity = 0;
		int expected = 0;
		assertEquals(expected, FractionalKnapsack.fractionalKnapsack(weight, value, capacity));
	}

	@Test
	public void testFractionalKnapsackWithNegativeWeightsOrValues() {
		int[] weight = new int[] { -10, 20, 30 };
		int[] value = new int[] { 60, 100, 120 };
		int capacity = 50;
		assertThrows(IllegalArgumentException.class,
				() -> FractionalKnapsack.fractionalKnapsack(weight, value, capacity));
	}

}